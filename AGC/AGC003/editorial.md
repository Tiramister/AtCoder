AGC003-A 「Wanna go back home」 (200)
===

[問題リンク](https://beta.atcoder.jp/contests/agc003/tasks/agc003_a)


### 概要

N, E, W, Sからなる文字列$S$が与えられる。

高橋くんは$|S|$日の旅行計画を立てており、$i$日目には$S$の$i$文字目の方角へ正の距離だけ直進する。

各日程の移動距離を適切に設定することで、旅行後に高橋くんが最初にいた場所に戻ってくることが可能か判定せよ。

### 制約

* $1 \leq |S| \leq 1000$


### 解説

$S$中に文字Nが出たとしよう。このとき、一度もSが出てこないとゴール地点はどうやってもスタート地点より北側にあることになる。逆に、一度でもSが出ればNとSでの移動距離の総和を一致させることで常にゴールとスタートの南北座標を一致させられる。

これはEとWでも同じことである。よって、各方角について出てきたかどうかを記録して、NとS、EとWそれぞれについてその情報が一致していればOKとなる。


### 実装例

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string S;
    cin >> S;

    const string way = "EWSN";
    bool dir[4];
    fill(dir, dir + 4, false);
    for (char c : S) {
        for (int i = 0; i < 4; ++i) {
            if (c == way[i]) dir[i] = true;
        }
    }

    if (dir[0] == dir[1] && dir[2] == dir[3]) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }
    return 0;
}
```

### 感想

* 「bool型のXORってどうやって出すんだっけ？」とか思っていた時期が私にもありました。
    * 答えは上のコードの通り。


---


AGC003-B 「Simplified mahjong」(400)
===

[問題リンク](https://beta.atcoder.jp/contests/agc003/tasks/agc003_b)


### 概要

$1 \sim N$まで書かれたカードがあり、$i$のカードは$A_i$枚ある。

差の絶対値が1以下のカード2枚でペアを作っていくとき、ペアの数の最大値を求めよ。

#### 制約

* $1 \leq N \leq 10^5$
* $0 \leq A_i \leq 10^9$


### 解説

結論を言ってしまうと、$i$が小さい方から以下のように貪欲にペアを作っていくのが最善策となる。

* $i$のカード2枚からなるペアをできるだけ作る。
* $i$と$i + 1$のカードのペアが作れるようなら作る。

なんで最適か証明しろって言われると難しい。editorialでは以下のように証明している。

> $A_i = 0$なる$i$が存在しない場合、$A_i$の合計を$S$とするとペア数の最大値は高々$\lceil S/2 \rceil$となる。そしてこの最大値は上の操作を適用することで達成可能である。
>
> $A_i = 0$なる$i$が存在する場合も、その$i$で分断すれば上のケースに帰着できる。よって上の操作が最適であることが示された。

上のような証明をしてから提出するのが理想だが、今回の場合は直感的に最適と感じやすいのでまぁそこまでしなくてもいいだろう。


### 実装例

場合分けを減らすため、「$N + 1$のカードが0枚ある」としている。

long longを使わないと制約上答えがオーバーフローするので注意。

```cpp
#include <iostream>
using namespace std;
using ll = long long;

int main() {
    int N;
    cin >> N;

    ll A[N + 1];
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
    }
    // N+1は0枚あるとすると実装しやすい
    A[N] = 0;

    ll ans = 0;
    for (int i = 0; i < N; ++i) {
        // i同士のペアを作れるだけ作る
        ans += A[i] / 2;
        A[i] %= 2;

        // iとi+1のペアを作れれば作る
        if (A[i] > 0 && A[i + 1] > 0) {
            ++ans;
            --A[i];
            --A[i + 1];
        }
    }

    cout << ans << endl;
    return 0;
}
```

上のコードでは、最終的な$A$は実際に操作を行ったあとの各カードの枚数と一致する。


### 感想

* 証明しにくい貪欲はやはり不安になる。


---


AGC003-C 「BBuBBBlesort!」 (600)
===
